<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IronSublimate</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ironsublimate.github.io/"/>
  <updated>2020-09-14T14:38:37.156Z</updated>
  <id>https://ironsublimate.github.io/</id>
  
  <author>
    <name>侯德柱</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>联合注意-联合激励代码分析</title>
    <link href="https://ironsublimate.github.io/2020/09/14/33845/"/>
    <id>https://ironsublimate.github.io/2020/09/14/33845/</id>
    <published>2020-09-14T14:06:56.000Z</published>
    <updated>2020-09-14T14:38:37.156Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 14 2020 22:50:18 GMT+0800 (中国标准时间) --><h1 id="coae源码分析">CoAE源码分析</h1><blockquote><p>侯德柱</p></blockquote><p><a href="https://github.com/timy90022/One-Shot-Object-Detection" target="_blank" rel="noopener">源代码</a> <a href="https://github.com/IronSublimate/One-Shot-Object-Detection-IS" target="_blank" rel="noopener">fork后的代码</a></p><h2 id="数据加载">数据加载</h2><h3 id="libroi_data_layerroibatchloader.py">lib/roi_data_layer/roibatchLoader.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">roibatchLoader</span><span class="params">(data.Dataset)</span>:</span></span><br></pre></td></tr></table></figure><ul><li><p>__init__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">             roidb: List[Dict[str, Any]],</span></span></span><br><span class="line"><span class="function"><span class="params">             ratio_list: np.ndarray,</span></span></span><br><span class="line"><span class="function"><span class="params">             ratio_index: np.ndarray,</span></span></span><br><span class="line"><span class="function"><span class="params">             query: List[Dict[int, Dict[str, Any]]],</span></span></span><br><span class="line"><span class="function"><span class="params">             batch_size: int,</span></span></span><br><span class="line"><span class="function"><span class="params">             num_classes: int,</span></span></span><br><span class="line"><span class="function"><span class="params">             training: bool = True,</span></span></span><br><span class="line"><span class="function"><span class="params">             normalize=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             seen: bool = True)</span>:</span></span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><p>成员变量</p><ul><li><p>self._cat_ids 在COCO中为1~90</p></li><li><p>self._classes字典，1<sub>80到1</sub>90映射</p></li><li><p>self.list</p><p>注意，filter只后的self.list应该等于imdb.list</p></li></ul></li><li><p>中间过程</p><ul><li>最后调用filter和probability</li></ul></li></ul></li><li><p>__getitem__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index: int)</span> -&gt; (torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor, int):</span></span><br></pre></td></tr></table></figure><ul><li><p>中间过程</p><ul><li><p>blob 即下面get_minibatch的返回值</p></li><li><p>query: np.ndarray 1x128x128x3</p><p>在138行变成torch.Tensor</p><p>之后换成1x3x128x128，并squeeze3x128x128</p></li><li><p>data是blob['data']变成Tensor，dtype=torch.float32，shape=[1,600,960,3]，已标准化</p></li></ul></li><li><p>返回值（训练）</p><ul><li><p>padding_data type=torch.float32 shape=[3,600,906]</p></li><li><p>query torch.float32 shape=[3,128,128]</p></li><li><p>im_info e.g.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.Tensor([<span class="number">600</span>,<span class="number">906</span>,<span class="number">1.4151</span>])</span><br></pre></td></tr></table></figure></li><li><p>gt_boxes_padding type=torch.float32 shape=[50x5]</p></li><li><p>num_bboxes 1</p></li></ul></li></ul></li><li><p>self.filter</p></li></ul><h3 id="libroi_data_layerminibatch.py">lib/roi_data_layer/minibatch.py</h3><ul><li><p>get_minibatch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_minibatch</span><span class="params">(roidb, num_classes)</span>-&gt; Dict[str, Any]:</span></span><br></pre></td></tr></table></figure><ul><li><p>返回值</p><table><thead><tr class="header"><th>key</th><th>type</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>data</td><td>np.ndarray</td><td>shape=(1,600,800,3)读取的图片 float32</td></tr><tr class="even"><td>gt_boxes</td><td>List[np.ndarray]</td><td>长度为nx5的向量(x,y,w,h,class) float32</td></tr><tr class="odd"><td>im_info</td><td>np.ndarray</td><td>shape=(1,3) float32</td></tr><tr class="even"><td>img_id</td><td>int</td><td></td></tr></tbody></table></li><li><ul><li></li></ul></li></ul></li></ul><h3 id="libroi_data_layerroidb.py">lib/roi_data_layer/roidb.py</h3><p>query类型 List[Dict[int, Dict[str, Any]]]</p><p>roidb类型 List[Dict[str, Any]]</p><ul><li><p>combined_roidb</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combined_roidb</span><span class="params">(imdb_names: str, training=True, seen=<span class="number">1</span>)</span>\</span></span><br><span class="line"><span class="function">-&gt; (imdb_, List[Dict[str, Any]], np.ndarray, np.ndarray, List[Dict[int, Dict[str, Any]]]):</span>:</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>imdb_names 数据集名称，为"coco_2017_train","voc_2007_trainval"等，以+分割不同的数据集</li></ul></li><li>返回值<ul><li>imdb</li></ul></li></ul></li><li><p>get_training_roidb</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_training_roidb</span><span class="params">(imdb, training)</span>:</span></span><br></pre></td></tr></table></figure><p>为combined_roidb的子函数</p></li><li><p>get_roidb</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_roidb</span><span class="params">(imdb_name: str, training: bool)</span> \</span></span><br><span class="line"><span class="function">-&gt; (imdb_, List[Dict[str, Any]], List[Dict[int, Dict[str, Any]]], List[int]):</span></span><br></pre></td></tr></table></figure><p>为combined_roidb的子函数</p><ul><li><p>参数</p><ul><li>imdb_name 数据集名称，为"coco_2017_train","voc_2007_trainval"等</li></ul></li><li><p>过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imdb.set_proposal_method(cfg.TRAIN.PROPOSAL_METHOD)</span><br></pre></td></tr></table></figure><p>如果按照cfgs的默认配置，该句会使self.roidb_handler=self.gt_roidb</p></li><li><p>返回值</p><ul><li><p><strong>imdb</strong></p></li><li><p><strong>roidb</strong> : 见下prepare_roidb</p></li><li><p><strong>cat_data</strong> 长度为81，key从0~80，每个value为一个List保存coco_class_ind对应的图片的bbox和图片路径，即<strong>query</strong></p><p>e.g.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">0</span>:[]</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>:[&#123;</span><br><span class="line">        <span class="string">'boxes'</span>: [<span class="number">339.88</span>, <span class="number">22.16</span>, <span class="number">492.76</span>, <span class="number">321.89000000000004</span>], </span><br><span class="line">        <span class="string">'image_path'</span>: <span class="string">'&lt;path to image&gt;\\000000391895.jpg'</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">'boxes'</span>: [<span class="number">471.64</span>, <span class="number">172.82</span>, <span class="number">506.56</span>, <span class="number">219.92</span>], </span><br><span class="line">        <span class="string">'image_path'</span>: <span class="string">'&lt;path to image&gt;\\000000391895.jpg'</span></span><br><span class="line">    &#125;, </span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span>:[</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>imdb.inverse_list长度为60，为选中的coco_cat_id(1~90)</p></li></ul></li></ul></li><li><p>prepare_roidb</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepare_roidb</span><span class="params">(imdb)</span> -&gt; List[Dict[str, Any]]:</span></span><br></pre></td></tr></table></figure><p>返回的imdb.roidb变成这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;<span class="string">'width'</span>: <span class="number">640</span>, </span><br><span class="line">     <span class="string">'height'</span>: <span class="number">360</span>, </span><br><span class="line">     <span class="string">'boxes'</span>: array([</span><br><span class="line">       [<span class="number">359</span>, <span class="number">146</span>, <span class="number">470</span>, <span class="number">358</span>],</span><br><span class="line">       [<span class="number">339</span>,  <span class="number">22</span>, <span class="number">492</span>, <span class="number">321</span>],</span><br><span class="line">       [<span class="number">471</span>, <span class="number">172</span>, <span class="number">506</span>, <span class="number">219</span>],</span><br><span class="line">       [<span class="number">486</span>, <span class="number">183</span>, <span class="number">515</span>, <span class="number">217</span>]], dtype=uint16), </span><br><span class="line">     <span class="string">'gt_classes'</span>: array([<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]),</span><br><span class="line">     <span class="string">'gt_overlaps'</span>: &lt;<span class="number">4</span>x81 sparse matrix of type <span class="string">'&lt;class '</span>numpy.float32<span class="string">'&gt;'</span></span><br><span class="line"><span class="keyword">with</span> <span class="number">4</span> stored elements <span class="keyword">in</span> Compressed Sparse Row format&gt;, </span><br><span class="line">     <span class="string">'flipped'</span>: <span class="literal">False</span>, </span><br><span class="line">     <span class="string">'seg_areas'</span>: array(</span><br><span class="line">         [<span class="number">12190.445</span>  , <span class="number">14107.271</span>  ,   <span class="number">708.26056</span>,   <span class="number">626.9852</span> ], dtype=float32), </span><br><span class="line">     <span class="string">'img_id'</span>: <span class="number">391895</span>, </span><br><span class="line">     <span class="string">'image'</span>: <span class="string">'&lt;path to image&gt;\\000000391895.jpg'</span>, </span><br><span class="line">     <span class="string">'max_classes'</span>: array([<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>], dtype=int64), </span><br><span class="line">     <span class="string">'max_overlaps'</span>: array([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], dtype=float32)&#125;</span><br><span class="line"> ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>rank_roidb_ratio</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rank_roidb_ratio</span><span class="params">(roidb: List[Dict[str, Any]])</span>-&gt;(np.ndarray,np.ndarray):</span></span><br></pre></td></tr></table></figure><p>针对roidb中的每一个图像，在ratio_list中记录宽/高。返回按ratio从小到大排序号的ratio_list，ratio_index，长度为训练集图像的总数，第一个dtype为float，第二个dtype为int64</p></li><li><p>test_rank_roidb_ratio</p><p>测试时调用</p></li></ul><h3 id="trainval_net.py">trainval_net.py</h3><h4 id="sampler">sampler</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sampler</span><span class="params">(Sampler)</span>:</span></span><br></pre></td></tr></table></figure><p>继承自torch.utils.data.sampler.Sampler</p><h2 id="数据集">数据集</h2><h3 id="libdatasetsimdb.py">lib/datasets/imdb.py</h3><h4 id="imdb">imdb</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">imdb</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Image database."""</span></span><br></pre></td></tr></table></figure><ul><li><p>__init__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name: str, classes=None)</span>:</span></span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>classes在所有的调用中为None</li></ul></li><li>成员变量<ul><li><strong>self._roidb_handler</strong></li><li><strong>self._classes</strong> 在子类中实现</li><li><strong>self.roidb</strong>是self._roidb_handler调用后的值</li><li><strong>self.roidb_handler</strong> 在coco.py中等于self.gt_roidb，在roidb.py中等于self.gt_roidb</li><li><strong>self.cat_data</strong> 就是query</li></ul></li></ul></li></ul><h3 id="libdatasetscoco.py">lib/datasets/coco.py</h3><h4 id="coco">coco</h4><ul><li><p>__init__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, image_set: str, year: str)</span>:</span></span><br></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><strong>image_set</strong> 为"train" "val" "test"</li><li><strong>year</strong>为"2014" "2017"</li></ul></li><li><p>成员变量</p><ul><li><p><strong>self._data_path</strong> 该路径下面应该有annotions和images两个文件夹</p></li><li><p><strong>self._roidb_handler</strong></p></li><li><p><strong>self._classes Tuple[(str)]</strong> 包括background</p></li><li><p><strong>self._class_to_ind</strong> 类别名到0~80的映射</p></li><li><p><strong>self._class_to_coco_cat_id</strong> 类别名到1-90映射</p></li><li><p><strong>self.coco_cat_id_to_class_ind</strong> 1<sub>90到1</sub>80的映射</p></li><li><p><strong>self.coco_class_ind_to_cat_id</strong> 1<sub>80到1</sub>90映射</p></li><li><p><strong>总之</strong> class代表类别名 coco_class_ind为1~80 coco_cat_id为1~90</p></li><li><p><strong>self._image_index</strong> =COCO.getImgIds()</p></li><li><p><strong>self._gt_splits</strong> = ('train', 'val', 'minival')</p></li><li><p><strong>self.reference_image</strong> Dict[int,Dict[int,Dict[str,Any]]]</p><p>图像检测结果字典，为每一张图像id为key，其的检测bbox的与实际对比的结果</p><p>e.g.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    391895: &#123;</span><br><span class="line">        1: &#123;</span><br><span class="line">            'category_id': 1, </span><br><span class="line">            'category_name': 'person', </span><br><span class="line">            'score': 0.9975148439407349, </span><br><span class="line">            'iou': 0.7170171752233037</span><br><span class="line">        &#125;, </span><br><span class="line">        2: &#123;</span><br><span class="line">            'category_id': 1, </span><br><span class="line">            'category_name': 'person', </span><br><span class="line">            'score': 0.9939727187156677, </span><br><span class="line">            'iou': 0.8616664860812628</span><br><span class="line">        &#125;, </span><br><span class="line">        0: &#123;'category_id': 4, </span><br><span class="line">            'category_name': 'motorcycle', </span><br><span class="line">            'score': 0.9700725078582764, </span><br><span class="line">            'iou': 0.8821412520463373</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    522418: &#123;</span><br><span class="line">        0: &#123;</span><br><span class="line">            'category_id': 1, </span><br><span class="line">            'category_name': 'person', </span><br><span class="line">            'score': 0.9950047135353088, </span><br><span class="line">            'iou': 0.8602898932977073</span><br><span class="line">        &#125;, </span><br><span class="line">        1: &#123;</span><br><span class="line">            'category_id': 49, </span><br><span class="line">            'category_name': 'knife', </span><br><span class="line">            'score': 0.9600722193717957, </span><br><span class="line">            'iou': 0.8965148825297287</span><br><span class="line">        &#125;, </span><br><span class="line">        2: &#123;</span><br><span class="line">            'category_id': 65, </span><br><span class="line">            'category_name': 'bed', </span><br><span class="line">            'score': 0.8499319553375244, </span><br><span class="line">            'iou': 0.910496123229155</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">  184613: &#123;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>self.cat_data</strong> Dict[int,List] key的范围1~90</p></li><li><p><strong>self.lis</strong>t 长度为60，是选出来用于训练的coco的cat_id，最大值90</p></li><li></li></ul></li></ul></li><li><p>filter</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span><span class="params">(self, seen: int = <span class="number">1</span>)</span>:</span></span><br></pre></td></tr></table></figure><p>根据命令行参数seen的值决定哪些类可见</p><ul><li><p>中间变量</p><ul><li><p><strong>cfg.train_categories</strong> 和cfg.test_categories**均为[1] self.list开始为[1]</p></li><li><p><strong>self.list</strong></p><p>上面两个cfg变量长度为1时self.list每4个数中在1<sub>80中取一个，保存的是cat_id的值(1</sub>90)</p></li><li><p><strong>self.inverse_list</strong>是根据上面的self.list保存1~80的值</p></li><li><p><strong>all_index</strong> 开始为0~所有图片的数量，先删掉类别在self.list中的图片</p></li><li><p>在此调用self.gt_roidb self.roidb就是self.gt_roidb的返回值</p></li><li><p>最后在self._image_index和self.roidb中删掉all_index中的图片，其保留的图片就是含有self.list中的</p></li><li><p>返回到roidb.py 的get_roidb</p></li></ul></li></ul></li><li><p>gt_roidb</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gt_roidb</span><span class="params">(self)</span>-&gt;List[Dict[str, Any]]</span></span><br></pre></td></tr></table></figure><ul><li><p>修改成员变量self.cat_data即query</p></li><li><p>返回值</p><p>e.g.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'width'</span>: <span class="number">640</span>, </span><br><span class="line">        <span class="string">'height'</span>: <span class="number">360</span>, </span><br><span class="line">        <span class="string">'boxes'</span>: array([</span><br><span class="line">           [<span class="number">359</span>, <span class="number">146</span>, <span class="number">470</span>, <span class="number">358</span>],</span><br><span class="line">           [<span class="number">339</span>,  <span class="number">22</span>, <span class="number">492</span>, <span class="number">321</span>],</span><br><span class="line">           [<span class="number">471</span>, <span class="number">172</span>, <span class="number">506</span>, <span class="number">219</span>],</span><br><span class="line">           [<span class="number">486</span>, <span class="number">183</span>, <span class="number">515</span>, <span class="number">217</span>]], dtype=uint16), </span><br><span class="line">        <span class="string">'gt_classes'</span>: array([<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]), </span><br><span class="line">        <span class="string">'gt_overlaps'</span>: &lt;<span class="number">4</span>x81 sparse matrix of type &lt;<span class="class"><span class="keyword">class</span> <span class="title">numpy</span>.<span class="title">float32</span>&gt;</span></span><br><span class="line">        with 4 stored elements in Compressed Sparse Row format&gt;, </span><br><span class="line">        <span class="string">'flipped'</span>: <span class="literal">False</span>, </span><br><span class="line">        <span class="string">'seg_areas'</span>: array(</span><br><span class="line">           [<span class="number">12190.445</span>  , <span class="number">14107.271</span>  , <span class="number">708.26056</span>,   <span class="number">626.9852</span> ], dtype=float32)</span><br><span class="line">    &#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>gt_classes的序号为1~80</p></li></ul></li><li><p>_load_coco_annotation</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_load_coco_annotation</span><span class="params">(self, index)</span>:</span></span><br></pre></td></tr></table></figure><p>生成roidb和self.cat_data即query</p></li><li><p>_get_ann_file(self)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_ann_file</span><span class="params">(self)</span>:</span></span><br></pre></td></tr></table></figure><p>根据"train" "val" "test"生成对应文件的路径</p></li></ul><h3 id="libdatasetsfactory.py">lib/datasets/factory.py</h3><ul><li><p>get_imdb</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_imdb</span><span class="params">(name:str)</span>-&gt;imdb:</span></span><br></pre></td></tr></table></figure><ul><li>数据集名，为"coco_2017_train","voc_2007_trainval"等</li></ul></li></ul><h3 id="自定义数据集">自定义数据集</h3><p>以coco为例</p><ol type="1"><li>修改coco.py中image_path_from_index读取图片的路径</li><li>修改coco.py中_get_ann_file读取ann_file的路径</li><li>在test_val.py中加对应的数据集名称</li><li>在factory.py中加__set[name]</li></ol><h2 id="数据处理">数据处理</h2><h3 id="libmodelutilblob.py">lib/model/util/blob.py</h3><ul><li><p>crop</p><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crop</span><span class="params">(image: np.ndarray, purpose: List[float], size: int)</span> -&gt; np.ndarray:</span></span><br></pre></td></tr></table></figure><p></p><p>裁剪图像</p><ul><li>参数<ul><li>image为np.ndarray</li><li>purpose为要裁剪的位置</li><li>size是裁剪后要resize的大小</li></ul></li></ul></li><li><p>prep_im_for_blob</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prep_im_for_blob</span><span class="params">(im: np.ndarray, pixel_means: np.ndarray, target_size: int, max_size: int)</span> -&gt; (np.ndarray, float):</span></span><br></pre></td></tr></table></figure><p>图片归一化并标准化</p><ul><li><p>参数</p><p>有用到的是im和target_size，target_size = 108</p></li><li><p>返回值</p><ul><li>处理后的图像</li><li>放大倍数，没用到</li></ul></li></ul></li><li><p>im_list_to_blob</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">im_list_to_blob</span><span class="params">(ims: List[np.ndarray])</span>-&gt;np.ndarray:</span></span><br><span class="line">    <span class="string">"""Convert a list of images into a network input.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Assumes images are already prepared (means subtracted, BGR order, ...).</span></span><br></pre></td></tr></table></figure><p>将List[np.ndarray]转成np.ndarray，其shape[0]为输入的list长度</p><ul><li>返回值<ul><li>shape为(1x128x128x3)，第一维是图片数量</li></ul></li></ul></li></ul><h2 id="训练">训练</h2><ul><li><p>在coco训练的时候dataset.list和mdb.list为</p><p>[2, 3, 4, 6, 7, 8, 10, 11, 13, 15, 16, 17, 19, 20, 21, 23, 24, 25, 28, 31, 32, 34, 35, 36, 38, 39, 40, 42, 43, 44, 47, 48, 49, 51, 52, 53, 55, 56, 57, 59, 60, 61, 63, 64, 65, 70, 72, 73, 75, 76, 77, 79, 80, 81, 84, 85, 86, 88, 89, 90]</p><p>在coco测试的时候</p><p>[2, 6, 10, 15, 19, 23, 28, 34, 38, 42, 47, 51, 55, 59, 63, 70, 75, 79, 84, 88]</p></li></ul><h2 id="魔改">魔改</h2><p>roibatchLoader.filter(seen)</p><ul><li><p>我不知道roibatchLoader的self.filter(seen)有什么用，在coco上面测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> dataset.list == imdb.list, (dataset.list, imdb.list)</span><br><span class="line"><span class="keyword">assert</span> dataset.list_ind == imdb.inverse_list, (dataset.list, imdb.list)</span><br></pre></td></tr></table></figure><p>均能通过</p><p>故将imdb作为形参，在roibatchLoader初始化的时候调用，取代filter以初始化list,list_ind</p></li></ul><h2 id="网络">网络</h2><figure><img src="https://github.com/IronSublimate/One-Shot-Object-Detection-IS/blob/master/images/method.png?raw=true" alt="method.png"><figcaption aria-hidden="true">method.png</figcaption></figure><h3 id="oneshotbase.py">oneshotbase.py</h3><h4 id="matchnet">matchnet</h4><ul><li><p>__init__.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inplanes: int)</span>:</span></span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>inplanes赋值给self.in_channels在coco中为1024</li></ul></li><li>成员变量<ul><li>self.in_channels=1024（coco）</li><li>self.inter_channels=self.in_channels//2（in coco = 512）</li><li>self.g 输入self.in_channels 输出self.inter_channel的1x1卷积</li><li>self.W输入self.inter_channels输出self.in_channels的1x1卷积，带batch_normalize</li><li>self.Q同self.W</li><li>self.theta self.phi 输入self.in_channels输出self.inter_channels的1x1卷积</li></ul></li></ul></li><li><p>forward</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, detect: torch.Tensor, aim: torch.Tensor)</span>:</span></span><br></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li>detect是输入图像（经过resnet提特征后）size=(1,1024,38,w) 对应batch_size channels h w</li><li>aim是查询图像（经过resnet提特征后）size=(1,1024,8,8) 对应batch_size channels h w</li></ul></li><li><p>中间变量</p><ul><li><p>d_x 为 detect经过self.g并变形之后size=(1,38×w ,512) 2546=38×w w={57 38 50}</p></li><li><p>a_x 为 aim经过self.g并变形之后size=(1,64,512) 64=8×8</p></li><li><p>theta_x为aim经过self.theta并变形后 size=(1,64,512)</p></li><li><p>phi_x为detect经过self.phi并变形后size=(1,512,38×w)</p></li><li><p>f=matmul(theta_x, phi_x) size=(1,64,38×w)矩阵乘法</p></li><li><p>f_div_C为f除以第二个维度长度，并变形为(1,64,38×w)</p></li><li><p>fi_div_C为f除以最后维度长度，并变形为(1,38×w,64)</p></li><li><p>non_aim ： non-local aim size=(1,1024,8,8) =matmul(f_div_C,d_x)+aim</p></li><li><p>non_det ： non-local detect size=(1,1024,38,w) =matmul(fi_div_C,a_x)+detect。对应F(I)</p></li><li><p>c_weight：size(1,1024,1,1)见下ChannelGate</p></li><li><p>act_aim：=non_aim * c_weight size(1,1024,8,8) activation</p></li><li><p>act_det：=non_det * c_weight size(1,1024,38,w) activation <span class="math display">\[ non\_aim=W(\theta(aim)\times\phi(dectect)/(38\times w)\times g(detect))+aim\\ non\_det=Q(\theta(aim)\times\phi(dectect)/64\times g(aim))+dectect\\ act\_aim=c\_weight*non\_aim\\ act\_det=c\_weight*non\_det \]</span></p><p><span class="math display">\[ non\_det是论文中的F(I)\\ non\_aim是论文中的F(p)\\ act\_det是论文中的\tilde{F}(I)\\ act\_aim是论文中的\tilde{F}(p) \]</span></p></li></ul></li><li><p>返回值</p><p>non_det, act_det, act_aim, c_weight</p></li></ul></li></ul><h4 id="oneshotbase">OneShotBase</h4><ul><li><p>__init__.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, classes:Tuple[str], class_agnostic:bool)</span>:</span></span><br></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li>classes就是imdb.classes。包括__background__</li><li>class_agnostic类别不可知=False</li></ul></li><li><p>成员变量</p><ul><li><p>RCNN_base 最开始的那个特征提取网络</p></li><li><p>RCNN_bbox_pred 2048-&gt;4的全连接网络</p></li><li><p>RCNN_cls_score 2N-&gt;8-&gt;2的那个网络</p></li><li><p>RCNN_proposal_target不参与反传，这层接到rpn_proposal_layer给的proposal,主要完成proposal跟gt的配对,然后传给loss进行学习</p></li><li><p>triplet_loss = torch.nn.MarginRankingLoss <span class="math display">\[ loss(x1,x2,y)=max(0,-y*(x1-x2)+margin) \]</span></p></li><li><p>_head_to_tail 在resnet中是一个resnet layer4，感觉是roi pool之后RCNN提取特征的，roi pool的结果和query生成的~F(p)都经过</p></li></ul></li></ul></li><li><p>forward</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, im_data:torch.Tensor, query:torch.Tensor, im_info:torch.Tensor, gt_boxes:torch.Tensor, num_boxes:torch.Tensor)</span>:</span></span><br></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li>im_data图片，size=(1,3,600,600)，猜测为(batch_size, channel, height, width)</li><li>query查询图片，size=(1, 3, 128, 128)</li><li>im_info=(600,600,0.9804) size=(1, 3) 在RCNN_RPN中使用</li><li>gt_boxes size=(1,50,5)</li><li>num_boxes size=1</li></ul></li><li><p>中间变量</p><ol type="1"><li>孪生网络</li></ol><ul><li>detect_feat： detect feature为im_data过了self.RCNN_base的torch.Tensor shape=(1,1024,38,38)</li><li>query_feat： query_feature为qurey过滤self.RCNN_base的torch.Tensor shape=(1,1024,8,8)</li></ul><ol start="2" type="1"><li>non-local feature</li></ol><ul><li>rpn_feat：为target Image的Non-local Feature size=(1,1024,57,38)</li><li>act_feat：为target Image激活后的图~F(I) size=(1,1204,57,38)</li><li>act_aim：为query Image激活后的图~F(p) size=(1,1204,8,8)</li><li>c_weight：联合注意的权重 size=(1,1204,1,1)</li></ul><ol start="3" type="1"><li>rpn</li></ol><ul><li>rois size=(1,2000,5)</li><li>rpn_loss_cls=0.6905 标量 requires_grad=True</li><li>rpn_loss_bbox=0.0162标量 requires_grad=True</li></ul><ol start="4" type="1"><li>self.RCNN_proposal_target 仅在训练中有</li></ol><ul><li>rois size=(1,128,5)</li><li>rois_label size= (1,128)</li><li>rois_target size= (1,128.4)</li><li>rois_inside_ws, size= (1,128,4)</li><li>rois_outside_ws size= (1,128,4)</li></ul><ol start="5" type="1"><li>self.RCNN_roi_align</li></ol><ul><li>pooled_feat size=(128, 1024, 7, 7)</li></ul><ol start="6" type="1"><li>head_to_tail</li></ol><ul><li>pooled_feat size=(128,2048)</li><li>query_feat size=(1,2048)</li></ul><ol start="7" type="1"><li>bbox_pred</li></ol><ul><li>size=(128,4)</li></ul><ol start="8" type="1"><li>cat 拼接roi和查询图像过R-CNN后的特征图pooled_feat 和query_feat</li></ol><ul><li><p>pooled_feat size=(128,4096)</p><p>猜测拼接后的结果是</p><table><thead><tr class="header"><th></th><th>roi[0:2048]</th><th>query[2048,4096]</th></tr></thead><tbody><tr class="odd"><td>0</td><td>roi0</td><td>query</td></tr><tr class="even"><td>1</td><td>roi1</td><td>query</td></tr><tr class="odd"><td>128</td><td>roi128</td><td>query</td></tr></tbody></table><p>bbox的损失用的拼接前的结果，score的损失用的拼接后的结果</p></li></ul><ol start="9" type="1"><li>RCNN_cls_score</li></ol><ul><li>score size=(128,2)</li><li>score_prob size=128 为score softmax后结果</li></ul><ol start="10" type="1"><li>R-CNN Loss cls</li></ol><ul><li>RCNN_loss_cls是score, rois_label的交叉熵</li></ul><ol start="11" type="1"><li>margin_loss</li></ol><ul><li>score_label size变为(1,128)</li><li>score_prob size变为(1,128)</li><li>gt_map=|score_label-score_label| 真值ground_turh size=(1,128,128)</li><li>pr_map=|score_prob-score_prob| 预测的predict size=(1,128,128)</li><li>target=-gt_map^2+3gt_map+1</li><li>margin_loss=3*self.triplet_loss()</li></ul><ol start="12" type="1"><li>RCNN_loss_bbox</li></ol><ul><li>RCNN_loss_bbox smooth-L1函数</li></ul></li><li><p>返回值</p><ul><li>rois</li><li>cls_prob</li><li>bbox_pred</li><li>rpn_loss_cls 用于反传</li><li>rpn_loss_bbox, 用于反传</li><li>RCNN_loss_cls, 用于反传</li><li>margin_loss, 用于反传</li><li>RCNN_loss_bbox， 用于反传</li><li>rois_label</li><li>c_weight</li></ul></li></ul></li></ul><h3 id="oneshotresnet.py">oneshotresnet.py</h3><h3 id="libmodelutilsnet_utils.py">lib/model/utils/net_utils.py</h3><h4 id="channelgate">ChannelGate</h4><p>用于squeeze</p><ul><li><p>__init__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, gate_channels: int, reduction_ratio: int = <span class="number">16</span>, pool_types: List[str] = [<span class="string">'avg'</span>, <span class="string">'max'</span>])</span></span></span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>gate_channels：=1024(coco)</li></ul></li><li>成员变量<ul><li>self.mlp 输入为gate_channels-&gt;gate_channels/16-&gt;ReLU-&gt;gate_channels网络编码解码器</li></ul></li></ul></li><li><p>forward</p><ul><li><p>参数</p><ul><li>x 是non_aim size=(1,1024,8,8)</li></ul></li><li><p>返回值</p><p>size=(1,1024,1,1)</p></li><li><p>过程</p><ol type="1"><li>x全局平均池化</li><li>self.mlp</li><li>x全局最大池化</li><li>self.mlp</li><li>4加上2的结果</li><li>sigmoid并返回</li></ol></li></ul></li></ul><h3 id="libmodelrpnrpn.py">lib/model/rpn/rpn.py</h3><h4 id="rpn">_RPN</h4><ul><li><p>__init__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, din: int)</span>:</span></span><br></pre></td></tr></table></figure><p>参数为通道数，在coco中为1024</p></li><li><p>forward</p><ul><li>参数，均为torch.Tensor<ul><li>base_feat 为target Image的Non-local Feature size=(1,1024,57,38)</li><li>im_info size=(1,3) =[[900,600,1.4052]]</li><li>gt_boxes size=(1,50,5)</li><li>num_boxes boxes的数量size=1</li></ul></li><li>返回值 均为torch.Tensor<ul><li>rois size=(1,2000,5)</li><li>rpn_loss_cls=0.6905 标量 requires_grad=True</li><li>rpn_loss_bbox=0.0162标量 requires_grad=True</li></ul></li></ul></li></ul><h3 id="libmodelrpnproposal_target_layer_cascade.py">lib/model/rpn/proposal_target_layer_cascade.py</h3><h4 id="proposaltargetlayer">_ProposalTargetLayer</h4><ul><li><p>__init__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nclasses: int)</span>:</span></span><br></pre></td></tr></table></figure></li><li><p>forward</p><ul><li>参数，均为torch.Tensor<ul><li>rois size=(1,2000,5)</li><li>gt_boxes size=(1,50,5)</li><li>num_boxes boxes的数量size=1</li></ul></li><li>返回值 均为torch.Tensor<ul><li>rois size=(1,128,5)</li><li>labels size= (1,128)</li><li>bbox_targets size= (1,128.4)</li><li>bbox_inside_weights, size= (1,128.4)</li><li>bbox_outside_weights size= (1,128.4)</li></ul></li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Sep 14 2020 22:50:18 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;coae源码分析&quot;&gt;CoAE源码分析&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;侯德柱&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/timy90022/One-Shot-Object-Detection&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源代码&lt;/a&gt; &lt;a href=&quot;https://github.com/IronSublimate/One-Shot-Object-Detection-IS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fork后的代码&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;数据加载&quot;&gt;数据加载&lt;/h2&gt;&lt;h3 id=&quot;libroi_data_layerroibatchloader.py&quot;&gt;lib/roi_data_layer/roibatchLoader.py&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;roibatchLoader&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(data.Dataset)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;__init__&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;             roidb: List[Dict[str, Any]],&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;             ratio_list: np.ndarray,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;             ratio_index: np.ndarray,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;             query: List[Dict[int, Dict[str, Any]]],&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;             batch_size: int,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;             num_classes: int,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;             training: bool = True,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;             normalize=None,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;             seen: bool = True)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="https://IronSublimate.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="https://IronSublimate.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>CenterNet代码分析</title>
    <link href="https://ironsublimate.github.io/2020/09/14/27078/"/>
    <id>https://ironsublimate.github.io/2020/09/14/27078/</id>
    <published>2020-09-14T13:53:48.000Z</published>
    <updated>2020-09-14T14:04:53.347Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 14 2020 22:50:17 GMT+0800 (中国标准时间) --><h1 id="centernet源码分析">CenterNet源码分析</h1><blockquote><p>侯德柱<br><a href="https://github.com/xingyizhou/CenterNet" target="_blank" rel="noopener">CenterNet源代码</a></p></blockquote><h2 id="概述">概述</h2><ol type="1"><li><p>src</p><ol type="1"><li><p>src/main.py主函数</p></li><li><p>src/demo.py展示测试结果图片</p></li><li><p>src/test.py测试数据</p></li></ol></li><li><p>src/lib</p><ol type="1"><li>src/lib/opts.py解析参数</li><li>src/lib/llogger.py</li><li>src/lib/datasets数据集文件夹<ol type="1"><li>src/lib/datasets/dataset实现加载哪个数据集，其每一个子类为数据集名字</li><li>src/lib/datasets/sample如何对数据采样，针对不同的网络返回什么信息，每一个子类为对应的网络名字</li></ol></li><li>src/lib/detectors检测方法集文件夹，包括如何训练，如何检测参数</li><li>src/lib/external实现nms？</li><li>src/lib/models基本网络结构，如dla、resnet、hourglass等</li><li>src/lib/trains实现trainer，网络结构构建</li></ol></li><li><p>src/tools数据集预处理<a id="more"></a> ## 命令行参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt.num_stacks = <span class="number">2</span> <span class="keyword">if</span> opt.arch == <span class="string">'hourglass'</span> <span class="keyword">else</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>## 简称<p></p></li></ol><ul><li>res : resolution</li><li>crop裁剪</li><li>reg_loss : regression loss</li></ul><h2 id="自定义数据集">自定义数据集</h2><ol type="1"><li>复制一个新建一个子类，继承data.Dataset</li><li>计算所有的图片的均值和标准差，并修改class.mean、class.std</li><li>class.num_class改为自己数据集的类别数</li><li>default_resolution为默认的分辨率</li><li>修改读取json文件的路径</li><li>修改self.class_name和self._valid_ids</li><li>将数据集加入src/lib/datasets/dataset_factory</li><li>在/src/lib/opts.py文件中修改self.parser.add_argument('--dataset'</li><li>修改src/lib/utils/debugger.py<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#（1）第45行下方加入两行：</span></span><br><span class="line"><span class="keyword">elif</span> num_classes == <span class="number">6</span> <span class="keyword">or</span> dataset == <span class="string">'food'</span>:</span><br><span class="line">    self.names = food_class_name</span><br><span class="line"><span class="comment"># （2）第460行下方加入自己所定义的类别，不包含背景：</span></span><br><span class="line">food_class_name = [<span class="string">'aaa'</span>, <span class="string">'bbb'</span>, <span class="string">'ccc'</span>, <span class="string">'ddd'</span>, <span class="string">'eee'</span>, <span class="string">'fff'</span>]</span><br></pre></td></tr></table></figure></li></ol><h2 id="自定义网络">自定义网络</h2><h3 id="srclibdatasetsample">src/lib/dataset/sample</h3><p>重写__getItem__</p><h3 id="自定义基础网络结构srclibmodel">自定义基础网络结构src/lib/model</h3><p>继承nn.Module，实现forward。不包括loss</p><h2 id="srclibmodels">src/lib/models</h2><h3 id="model.py">model.py</h3><ul><li><p>create_model</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_model</span><span class="params">(arch: str, heads: Dict[str, int], head_conv: int)</span> -&gt; nn.Module:</span></span><br></pre></td></tr></table></figure><p>所有基本网络结构的get_model参数与本函数一致</p><ul><li><p>参数</p><ul><li><p>arch网络架构 命令行参数--arch确定</p></li><li><p>heads opt.heads确定，key为特征名字，value为值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> opt.task == <span class="string">'ctdet'</span>:</span><br><span class="line">    <span class="comment"># assert opt.dataset in ['pascal', 'coco']</span></span><br><span class="line">    opt.heads = &#123;<span class="string">'hm'</span>: opt.num_classes,</span><br><span class="line">                 <span class="string">'wh'</span>: <span class="number">2</span> <span class="keyword">if</span> <span class="keyword">not</span> opt.cat_spec_wh <span class="keyword">else</span> <span class="number">2</span> * opt.num_classes&#125;</span><br><span class="line">    <span class="keyword">if</span> opt.reg_offset:</span><br><span class="line">        opt.heads.update(&#123;<span class="string">'reg'</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>head_conv 命令行参数--head_conv 确定 output head的卷积层通道数 0 没有卷积层，-1默认:resnet64,dla256</p></li></ul></li><li><p>返回值</p><ul><li>基本网络架构</li></ul></li></ul></li></ul><h3 id="networks">networks</h3><p>forward返回值</p><h4 id="resnet_dcn.py">resnet_dcn.py</h4><h5 id="poseresnet">PoseResNet</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoseResNet</span><span class="params">(nn.Module)</span>:</span></span><br></pre></td></tr></table></figure><ul><li><p>__init__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, block: Type[BasicBlock], layers: List[int, int, int, int], heads: Dict[str, int], head_conv: int)</span>:</span></span><br></pre></td></tr></table></figure><ul><li><p>成员变量</p><ul><li><p>self.head是字典，key为分支名称(hm,wh,reg)，value为最后输出的通道数=数据集类别数</p></li><li><p>构造函数最后根据head的key，用__setattr__把key设成属性名，成员变量的值是卷积层的model，输入256通道，输出数据集类别数通道</p></li></ul></li></ul></li><li><p>forward</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x: torch.Tensor)</span> -&gt; List[Dict[str, torch.Tensor]]</span></span><br></pre></td></tr></table></figure><ul><li>返回值中每一个元素是head不同key的全连接层对应前向传播的结果，list的长度为1<ol type="1"><li>hm：热力图size=(1,2,128,128)为 (batch size ,num of classes, H/R,W/R)</li><li>wh：宽高size=(1,2,128,128)为 (batch size ,2, H/R,W/R)</li><li>reg：回归误差size=(1,2,128,128)为 (batch size ,2, H/R,W/R)</li></ol></li></ul></li></ul><h3 id="losses">losses</h3><h4 id="regl1loss">RegL1Loss</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegL1Loss</span><span class="params">(nn.Module)</span>:</span></span><br></pre></td></tr></table></figure><ul><li>__init__</li><li>forward<ul><li>中间变量<ul><li>pred size=(1,128,2)</li><li>mask size=(1,128,2)</li></ul></li></ul></li></ul><h2 id="srclibtrains">src/lib/trains</h2><h3 id="modelwithloss">ModelWithLoss</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelWithLoss</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model: torch.nn.Module, loss: torch.nn.Module)</span>:</span></span><br><span class="line">        super(ModelWithLoss, self).__init__()</span><br><span class="line">        self.model = model</span><br><span class="line">        self.loss = loss</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, batch: dict)</span> -&gt; (Dict[str, torch.Tensor], torch.Tensor, Dict[str, torch.Tensor]):</span></span><br><span class="line">        outputs = self.model(batch[<span class="string">'input'</span>])</span><br><span class="line">        loss, loss_stats = self.loss(outputs, batch)</span><br><span class="line">        <span class="keyword">return</span> outputs[<span class="number">-1</span>], loss, loss_stats</span><br></pre></td></tr></table></figure><p>outputs为network的输出，List[Dict[str, torch.Tensor]]</p><p>model为网络前向传播的输出，不包括loss</p><p>返回值</p><ul><li>loss Tensor标量</li><li>loss_stats</li></ul><h3 id="basetrainer">BaseTrainer</h3><ul><li><p>__init__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, opt: Namespace, model: torch.nn.Module, optimizer: Optional[torch.optim.Adam] = None)</span>:</span></span><br></pre></td></tr></table></figure><ul><li>opt为命令行参数</li><li>model为src/lib/model中定义的model</li><li>optimizer为优化器，main.py中用的adam</li><li>self.loss_stats, self.loss = self._get_losses(opt)</li><li>self.model_with_loss = ModelWithLoss</li></ul></li><li><p>run_epoch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_epoch</span><span class="params">(self, phase: str, epoch: int, data_loader: torch.utils.data.DataLoader)</span></span></span><br></pre></td></tr></table></figure><ul><li>主要功能：<ol type="1"><li>对model_with_loss正向传播和反向传播，使用optimizer优化</li><li>计时</li><li>每5轮验证一次</li></ol></li><li>参数<ul><li>phase为'train'或'val'</li></ul></li><li>中间变量<ul><li>batch是dataloader返回的字典</li></ul></li><li>需要用到的成员函数<ul><li>opt<ul><li>task</li><li>exp_id</li></ul></li><li>model_with_loss</li></ul></li></ul></li><li><p>debug</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(self, batch: dict, output: List[Dict[str, torch.Tensor]], iter_id: int)</span>:</span></span><br></pre></td></tr></table></figure><p>需自己实现</p></li><li><p>save_result</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_result</span><span class="params">(self, output: Dict[str, torch.Tensor], batch: dict, results: dict)</span>:</span></span><br></pre></td></tr></table></figure><p>需自己实现</p><p>run_epoch中results传入的是空，results作为返回值</p></li><li><p>_get_loss</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_losses</span><span class="params">(self, opt: Namespace)</span> -&gt; (List[str], torch.nn.Module):</span></span><br></pre></td></tr></table></figure><p>需自己实现</p><ul><li>返回值<ul><li>List[str]是损失分量的名字</li></ul></li></ul></li><li><p>train &amp; val</p><p>分别调用run_epoch("train") run_epoch("val")</p></li></ul><h2 id="srclibdetectors">src/lib/detectors</h2><p>该类为检测类，使用训练好的模型检测</p><ul><li><p>pre_process</p><p></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre_process(self, image: np.ndarray, scale: float, meta: Optional[list] = None) -&gt; (np.ndarray, dict)</span><br></pre></td></tr></table></figure>预处理，默认是实现图片放缩，meta在除ddd之外的检测器没用<p></p></li><li><p>process</p><p></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process(self, images: torch.Tensor, return_time=False)-&gt; Tuple[dict, torch.Tensor, float]:</span><br></pre></td></tr></table></figure>必须自己实现<p></p><p>第一个dict为检测结果output，第二个Tensor为检测结果的bbox和置信度等数据，需要自己实现[网络名]_decode函数在src/lib/models/decode.py中，最后一个参数为检测开始时间，如果return_time=False则为0</p></li><li><p>post_process</p><p></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_process(self, dets: torch.Tensor, meta: dict, scale: float = 1) -&gt; Dict[int, Iterable]</span><br></pre></td></tr></table></figure>必须自己实现<p></p><p>反缩放，dets经[网络名]_post_process函数处理后返回检测框的信息（bbox，概率，类别）？</p></li><li><p>merge_outputs</p><p></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">merge_outputs(self, detections: List[Dict[int, Iterable]]) -&gt; Dict[int,np.ndarray]</span><br></pre></td></tr></table></figure>必须自己实现<p></p></li><li><p>debug</p><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug(self, debugger: Debugger, images: np.ndarray, dets: torch.Tensor, output, scale: float = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>dets为detections的简写<p></p></li><li><p>show_results</p><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show_results(self, debugger: Debugger, image: np.ndarray, results: Dict[int, np.ndarray])</span><br></pre></td></tr></table></figure>显示测试结果的图片<p></p></li><li><p>以上这些函数会在基类中run函数调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(self, image_or_path_or_tensor: Union[str, np.ndarray, Dict[str, List[torch.Tensor]]], meta:Optional[list]=<span class="literal">None</span>):</span><br></pre></td></tr></table></figure><p></p></li></ul><p>，</p><h2 id="srclibutils">src/lib/utils</h2><h3 id="srclibutilsdebugger.py">src/lib/utils/debugger.py</h3><p>用于展示图片，</p><h3 id="srclibutilspost_process.py">src/lib/utils/post_process.py</h3><p>自定义检测完处理函数，整理检测结果</p><ul><li><p>ctdet_post_process</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctdet_post_process(dets: np.ndarray, c: Union[list, np.ndarray], s: Union[list, np.ndarray],h: int, w: int, num_classes: int) -&gt; List[Dict[int, Iterable]]:</span><br></pre></td></tr></table></figure></li></ul><p>dets: batch x max_dets x dim 批大小×最多检测出多少个×维度。在ctdet中，dim的大小为6，前4个参数为x1,y1,x2,y2；第5个参数为概率；第6个参数为类别</p><p>返回中的dict的key为类别，Iterable为np.nparray</p><h3 id="srclibutilsimage.py">src/lib/utils/image.py</h3><p>图像预处理</p><ul><li><p>transform_preds</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform_preds(coords: np.ndarray, center: np.ndarray,</span><br><span class="line">                    scale: Union[np.ndarray, list, int], output_size: Sequence)</span><br></pre></td></tr></table></figure><p>对点进行仿射变换</p><p>coords为坐标点的矩阵[[x0,y0],[x1,y1],...]，center中心，scale放大倍数，rot旋转，output_size输出尺寸为长度2的向量</p></li><li><p>get_affine_transform</p><p></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">get_affine_transform(center: np.ndarray,</span><br><span class="line">                         scale: Union[np.ndarray, list, int],</span><br><span class="line">                         rot: float,</span><br><span class="line">                         output_size: Sequence,</span><br><span class="line">                         shift=np.array([<span class="number">0</span>, <span class="number">0</span>], dtype=np.float32),</span><br><span class="line">                         inv=0) -&gt; np.ndarray:</span><br></pre></td></tr></table></figure><p></p><p>得到仿射变换矩阵，center中心，scale放大倍数，rot旋转，output_size输出尺寸为长度2的向量，</p></li><li><p>affine_transform</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">affine_transform(pt: np.ndarray, t: np.ndarray)</span><br></pre></td></tr></table></figure><p>pt长度为2的向量，t仿射变换矩阵</p></li><li><p>draw_msra_gaussian draw_umich_gaussian</p><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw_umich_gaussian(heatmap, center, radius, k=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p></p><p>TODO:</p></li><li><p>color_aug</p><p></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color_aug(data_rng:int, image:np.ndarray, eig_val:np.ndarray, eig_vec:np.ndarray) -&gt; None</span><br></pre></td></tr></table></figure><p></p><p>图片增强，直接在原图像上修改</p><ul><li>data_rng为随机数种子，默认np.random.RandomState(123)</li><li>image归一化的图片</li><li>eig_val default = np.array([0.2141788, 0.01817699, 0.00341571], dtype=np.float32)</li><li>eig_vec default = np.array([ [-0.58752847, -0.69563484, 0.41340352], [-0.5832747, 0.00994535, -0.81221408], [-0.56089297, 0.71832671, 0.41158938] ], dtype=np.float32)</li></ul></li><li><p>draw_dense_reg</p><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw_dense_reg(regmap, heatmap, center, value, radius, is_offset=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p></p></li></ul><h2 id="cocoapi">COCOAPI</h2><ul><li><p>COCO.loadImgs</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadImgs(self, ids:Union[int,Sequence]=[])-&gt;List[dict]</span><br></pre></td></tr></table></figure><p>返回图片文件名等信息</p><p>e.g.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"license"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"file_name"</span>: <span class="string">"000000324158.jpg"</span>,</span><br><span class="line">        <span class="attr">"coco_url"</span>: <span class="string">"http://images.cocodataset.org/val2017/000000324158.jpg"</span>,</span><br><span class="line">        <span class="attr">"height"</span>: <span class="number">334</span>,</span><br><span class="line">        <span class="attr">"width"</span>: <span class="number">500</span>,</span><br><span class="line">        <span class="attr">"date_captured"</span>: <span class="string">"2013-11-19 23:54:06"</span>,</span><br><span class="line">        <span class="attr">"flickr_url"</span>: <span class="string">"http://farm1.staticflickr.com/169/417836491_5bf8762150_z.jpg"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">324158</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>COCO.getAnnIds</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getAnnIds(self, imgIds:List[int]=[], catIds:List[int]=[], areaRng:List[float]=[], iscrowd:bool=None)-&gt;List[int]</span><br></pre></td></tr></table></figure><p>e.g.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10673</span>, <span class="number">345846</span>, <span class="number">349287</span>, <span class="number">351168</span>, <span class="number">353731</span>, <span class="number">359808</span>, <span class="number">638724</span>, <span class="number">1192678</span>, <span class="number">1194317</span>, <span class="number">1341598</span>, <span class="number">1346450</span>, <span class="number">1348862</span>, <span class="number">2038341</span>, <span class="number">2044744</span>, <span class="number">2162813</span>]</span><br></pre></td></tr></table></figure></li><li><p>COCO.loadAnns</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadAnns(self, ids=[])-&gt;List[dict]</span><br></pre></td></tr></table></figure><p>加载标记，</p><p>e.g.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        'segmentation': [[</span><br><span class="line">            44.2, 167.74, 48.39, 162.71, 66.87, 161.19, 72.75, 162.71, 80.98, 164.22, 80.14, 168.92, 78.12, 168.58, 72.24, 170.94, 71.74, 173.79, 54.27, 174.97, 52.59, 170.1, 50.75, 167.91, 45.71, 168.92, 45.2, 167.58</span><br><span class="line">        ]], </span><br><span class="line">        'area': 331.9790999999998, </span><br><span class="line">        'iscrowd': 0, </span><br><span class="line">        'image_id': 324158, </span><br><span class="line">        'bbox': [44.2, 161.19, 36.78, 13.78], </span><br><span class="line">        'category_id': 3, </span><br><span class="line">        'id': 345846</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li></li></ul><h2 id="ctdet">ctdet</h2><h3 id="samplectdet.py">sample/ctdet.py</h3><h4 id="ctdetdataset.__getitem__">CTDetDataset.__getitem__</h4><blockquote><p>设原图片维度为W*H*3</p></blockquote><ul><li><p>CTDetDataset.__getitem__返回值</p><table><colgroup><col style="width:17%"><col style="width:11%"><col style="width:70%"></colgroup><thead><tr class="header"><th style="text-align:left">key</th><th>value</th><th>备注</th></tr></thead><tbody><tr class="odd"><td style="text-align:left">'input'</td><td>np.ndarray</td><td>输入图片shape=[3x512x512]</td></tr><tr class="even"><td style="text-align:left">'hm'</td><td>np.ndarray</td><td>heatmap size (num_classes, output_h, output_w), (80x128x128)(dtype=np.float32 正态分布，中心为bbox中心，w和h为bbox的w和h</td></tr><tr class="odd"><td style="text-align:left">'reg_mask'</td><td>np.ndarray</td><td>dtype=uint8 shape=[128] [1 1 1 1 1 1 0 0 ...]</td></tr><tr class="even"><td style="text-align:left">'ind'</td><td></td><td>dtype=int64 shape=[128] mask为1的地方有值</td></tr><tr class="odd"><td style="text-align:left">'wh'</td><td></td><td>dtyte=float32 shape=[128x2] mask为1的地方有值</td></tr><tr class="even"><td style="text-align:left">'dense_wh'</td><td></td><td></td></tr><tr class="odd"><td style="text-align:left">'dense_wh_mask'</td><td></td><td></td></tr><tr class="even"><td style="text-align:left">'cat_spec_wh'</td><td></td><td></td></tr><tr class="odd"><td style="text-align:left">'cat_spec_mask'</td><td></td><td></td></tr><tr class="even"><td style="text-align:left">'reg'</td><td></td><td>dtyte=float32 shape=[128x2] mask为1的地方有值，其他为0</td></tr><tr class="odd"><td style="text-align:left">'meta'</td><td>dict</td><td>见下方，非训练或debug时才有</td></tr></tbody></table><ul><li><p>meta</p><table><thead><tr class="header"><th>key</th><th>value type</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>'c'</td><td>np.ndarray</td><td>仿射变换的center，(x,y)长度为2的向量，dtype=np.float32，默认为图片中心点</td></tr><tr class="even"><td>'s'</td><td>float</td><td>仿射变换的scale</td></tr><tr class="odd"><td>'gt_det'</td><td></td><td></td></tr><tr class="even"><td>'img_id'</td><td></td><td></td></tr></tbody></table></li></ul></li><li><p>变量</p><table><thead><tr class="header"><th>变量名</th><th>type</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>inp</td><td>np.ndarray</td><td>input输入图片，80行transpose(2,0,1)将其变为3*W*H</td></tr><tr class="even"><td>num_objs</td><td>int</td><td>图像中标记的矩形框数量和self.max_objs最小值</td></tr><tr class="odd"><td></td><td></td><td></td></tr><tr class="even"><td>opt.no_color_aug</td><td>bool</td><td>default=False <strong>不</strong>进行色彩增强，默认增强</td></tr><tr class="odd"><td>opt.keep_res</td><td>bool</td><td>default=False保持分辨率</td></tr><tr class="even"><td>opt.flip</td><td>float</td><td>图片翻转概率</td></tr><tr class="odd"><td>opt.down_ratio</td><td>int</td><td>default=4 下采样率</td></tr><tr class="even"><td>opt.dense_wh</td><td>bool</td><td>default=False 中心点附件加权回归或中心点回归</td></tr><tr class="odd"><td></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td></td></tr></tbody></table><ul><li><p>input image(inp)</p><ul><li>39行cv2.imread</li><li>68行opt.flip按概率翻转</li><li>73行仿射变换</li><li>76行归一化（÷255）</li><li>79行变正态分布</li><li>80行transpose(2,0,1)将其维度变为3*W*H</li><li>最后作为res['inp']返回</li></ul></li><li><p>bbox为目标矩形框</p><ul><li>102行转为x1,y1,x2,y2</li><li>105行根据图像翻转</li><li>106行仿射变换</li><li>108行裁剪使其不超过图片的边界</li><li>bbox用来生成heatmap，返回值中没有bbox</li></ul></li><li><p>heatmap</p><p>hm维度为num_classes×output_h×output_w</p><p>对于coco，num_classes=80。output_h×output_w 默认为输入图片的高宽分别除以4</p><p>dtype=np.float32</p><p>如果bbox中没有对应的类别，则该类的heatmap为0</p><p>由image.py中gaussian_radius和</p></li></ul></li></ul><h4 id="其他函数">其他函数</h4><ul><li><p>CTDetDataset._coco_box_to_bbox</p><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_coco_box_to_bbox(self, box:Sequence)-&gt;np.ndarray</span><br></pre></td></tr></table></figure><p></p><p>将(x,y.w,h)变为(x1,y1,x2,y2)，左上和右下的坐标</p></li></ul><h3 id="trainsctdet.py">trains/ctdet.py</h3><h4 id="ctdetloss">CtdetLoss</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtdetLoss</span><span class="params">(torch.nn.Module)</span>:</span></span><br></pre></td></tr></table></figure><ul><li><p>__init__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, opt)</span>:</span></span><br></pre></td></tr></table></figure><ul><li>成员变量<ul><li>self.crit是一个heatamp损失函数，返回值为torch.Tensor标量</li><li>self.crit_hw是长宽损失函数</li><li>self.crit_reg是修正误差损失函数</li></ul></li></ul></li><li><p>forward</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, batch: dict)</span> -&gt; (object, torch.Tensor, Dict[str, torch.Tensor]):</span></span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>batch是dataloader __getitem__的返回值</li></ul></li><li>返回值<ul><li>outputs是model/network中前向传播的返回值</li><li>loss是标量torch.Tensor</li><li>loss_stats是字典，损失分量的名字为key和其数值的Tensor为value</li></ul></li></ul></li></ul><h4 id="ctdettrainer">CtdetTrainer:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtdetTrainer</span><span class="params">(BaseTrainer)</span>:</span></span><br></pre></td></tr></table></figure><h3 id="section"></h3><h2 id="test.py">test.py</h2><h3 id="输出">输出</h3><h4 id="bar.suffix">Bar.suffix</h4><p>[当前轮数/总轮数]|Tot:总时间|ETA:剩余时间|tot总时间|load载入时间|pre预处理时间|net|dec|post|merge|</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Sep 14 2020 22:50:17 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;centernet源码分析&quot;&gt;CenterNet源码分析&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;侯德柱&lt;br&gt;&lt;a href=&quot;https://github.com/xingyizhou/CenterNet&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CenterNet源代码&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;&lt;p&gt;src&lt;/p&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;&lt;p&gt;src/main.py主函数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;src/demo.py展示测试结果图片&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;src/test.py测试数据&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;src/lib&lt;/p&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;src/lib/opts.py解析参数&lt;/li&gt;&lt;li&gt;src/lib/llogger.py&lt;/li&gt;&lt;li&gt;src/lib/datasets数据集文件夹&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;src/lib/datasets/dataset实现加载哪个数据集，其每一个子类为数据集名字&lt;/li&gt;&lt;li&gt;src/lib/datasets/sample如何对数据采样，针对不同的网络返回什么信息，每一个子类为对应的网络名字&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;src/lib/detectors检测方法集文件夹，包括如何训练，如何检测参数&lt;/li&gt;&lt;li&gt;src/lib/external实现nms？&lt;/li&gt;&lt;li&gt;src/lib/models基本网络结构，如dla、resnet、hourglass等&lt;/li&gt;&lt;li&gt;src/lib/trains实现trainer，网络结构构建&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;src/tools数据集预处理&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="https://IronSublimate.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="https://IronSublimate.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>C语言补充</title>
    <link href="https://ironsublimate.github.io/2020/09/14/42787/"/>
    <id>https://ironsublimate.github.io/2020/09/14/42787/</id>
    <published>2020-09-14T02:58:06.000Z</published>
    <updated>2020-09-14T04:28:41.011Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 14 2020 22:50:17 GMT+0800 (中国标准时间) --><h1 id="编译期和运行期未定义行为">编译期和运行期，未定义行为</h1><p>C语言和C++中一些规范是针对编译期的，一些是针对运行期的。在学习的时候要关注哪些是编译期的规定，哪些是运行期的规定。<br>C语言和C++有大量的未定义行为，具体实现取决于编译器的设计。比如i=1;(++i)+(i++)的值就是未定义的。不同编译器结果不同。在一条语句中，对一个变量改变两次及以上的结果是未定义的。还有一个，int占多少字节也是标准中没有规定的，标准中只规定int至少是16位，int长度不能小于short。int的长度是编译器决定的。在32位、64位CPU中，编译器的int长度一般是32位。<br>不要把某一种编译器测试的结果就当成C和C++的标准。编译器是根据标准实现的。<a id="more"></a> # C/C++标准 C语言目前的标准有C89、C99、C11等。<br>C++目前的标准C++98、C++11、C++14、C++17、C++20等<br>每个标准最后两个数字代表发表的年号。<br>我们学的是C89和C++98<br>本章所用标准均为C99和C++14</p><h2 id="c99新增特性">C99新增特性</h2><p>任意位置定义变量，不必必须在函数开始定义<br>inline关键字（与C++inline作用基本相同）<br>列表初始化结构体的时候指定属性<br>&lt;stdint.h&gt; &lt;iso646.h&gt;头文件<br>_Bool类型，增加&lt;stdbool.h&gt;头文件</p><h1 id="cc编译过程">C/C++编译过程</h1><p>以下为编译过程中主要完成的工作。<br>无论是PC的程序，还是单片机的程序，在使用C/C++生成程序时经过编译，链接两个过程。<br>编译(compile)：将C/C++源程序（后缀名为.c或.cpp等，还可以是汇编程序），生成二进制目标文件（后缀名为.o或.obj）。这一步由编译器完成。.o文件记录了文件中都定义了哪些函数，外部变量。<br>链接：将所有的.o文件合并成可执行文件。这一步由链接器完成。在这一步中，链接器在所有的.o文件中找到主函数，以及主函数所调用的函数。将它们放到一起，生成可执行文件。<br>注意：编译器和链接器是两个不同的程序。现在在IDE中一般把两步集成在一起。IAR中叫make，vs中叫生成xx项目，keil叫build。</p><p><img src="/2020/09/14/42787/compile.png"> 理解编译和链接非常重要。对理解之后的定义声明，C和C++相互调用，报错时找到原因都有很大的作用。</p><p>分成编译、链接两步的好处<br>1. 在生成.o的过程中，如上，一个工程文件有多个.c .cpp源程序，可以让CPU多个核心同时编译a.c b.c c.pp文件，节省编译时间。（c++是编译最慢的语言） 2. 当其中一个源文件修改后，编译器只用重新编译该文件，不用编译其他文件。e.g.当a.c被修改后，编译器只用重新生成a.o文件，不用再生成c.o b.o文件，之后链接。 3. .o文件不仅可以由C、C++源程序生成，还可以由汇编、fortran等语言生成，方便不同语言之间的调用。</p><h2 id="定义和声明">定义和声明</h2><p>注意：在编译不同源文件的时候，是不会知道其他文件里有什么内容的。编译a.c的时候不知道b.c、c.cpp这些文件里定义了哪些函数。那么a.c里面的函数是怎么调用其他文件里面的函数呢？<br>这就需要在a.c文件中对外面的函数声明。<br>假设a.c文件里面有函数void fun_a()，调用了b.c文件里面的函数void fun_b()，则a.c文件中代码应该如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****a.c******/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span>;<span class="comment">//声明fun_b</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// void fun_b();//这里也可以声明fun_b</span></span><br><span class="line">    fun_b();<span class="comment">//调用fun_b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明可以多次，（非内联）函数和变量定义只能有一次。这里void fun_b();就是对fun_b函数的声明，void fun_a(){}是对fun_a的定义，fun_b();是在fun_a中调用fun_b。<br>声明的作用是，告诉编译器，在其他地方有这样一个函数叫fun_b，它返回void，形参为void。在调用fun_b中，编译器在生成.o的时候就标记了这里调用了这样一个函数，名字是fun_b，返回void，形参为void。链接的时候链接器就在各个.o文件中找有没有对应的函数，之后生成正确的跳转地址的机器码来保证正确调用这个函数。如果我们在b.c中忘记定义fun_b，或者fun_b没有写成下面的样子，则会在链接的时候报错，注意，编译没错，错误在链接时出现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****b.c******/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，定义就是告诉编译器这个东西是什么，怎么实现的，声明是告诉编译器有这么个东西，编译的时候不要感到奇怪，它在哪是链接器的事情。<br>多个文件使用同一个全局变量也是如此，关于变量的定义和声明以及C和C++源程序之间相互调用见后。</p><h1 id="宏">宏</h1><p>宏是一种预处理机制。在编译的第一步就是对整个源程序的宏进行处理。宏可以看作是一种功能不完整的生成代码的编程语言，由于编译是按照文件编译，宏的作用范围也是当前文件。<br>在学习本章时要时刻注意宏只是一种在文字上预处理，对源代码完成替换、粘贴、删除等工作。</p><h2 id="include">#include</h2><p>#include宏在预处理的时候是把#include语句用对应的文件内容替换。以Helloworld程序为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello,world!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在编译的第一步，就是把stdio.h这个文件的全部内容复制到第一行。&lt;stdio.h&gt;文件太长了就不展示预处理后是什么样子了，请自己脑补。所以，如果你将来进的公司是按代码行数发工资，你就可以把整个&lt;stdio.h&gt;文件复制到你的代码中，效果和#include&lt;stdio.h&gt;一样。<br>#inlcude的作用，是可以把一些共用的代码（比如函数、变量的声明）放到一个头文件中，减少重复的输入。<br>例：<br>第一节的例子中我们在a.c中调用了b.c定义的函数fun_b，需要在a.c中声明void fun_b();如果我们需要调用b.c中定义的其他函数fun_b2、fun_b3，就要都声明一遍。如果除了a.c，d.c等其他文件都需要调用b.c的函数，每个文件都声明一次就很麻烦。我们可以新建一个b,h把声明的部分放到b.h（文件取名任意）中。b.h如下<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****b.h******/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_b2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_b3</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>注：<br>1. 理论上#include可以在任何位置，只要保证#include展开后代码没有错误即可。但一般习惯将#include放在文件头部 2. #include后面的文件名扩展名可以任意。#include "sb.c"，#include "sb.txt"均可，无扩展名也可，C++的标准库头文件均无扩展名，如#include<iostream><p></p><h2 id="define">#define</h2><ol type="1"><li>定义常量 例：#define PI 3.14<br>在编译的前当前文件所有的PI就会被替换为3.14</li><li>定义宏函数 例 #define MAX(a,b) ((a)&gt;(b)?(a):(b))<br>若源程序中有 now_value = MAX(now_value, last_value); 宏处理后为 now_value = ((now_value)&gt;( last_value)?( now_value):( last_value));</li><li>实现条件编译<br>见下一节#if</li></ol><p>#undef 可以取消之前的#define，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="comment">//some code</span></span><br><span class="line">undef PI</span><br></pre></td></tr></table></figure>//之后PI 就认为没有定义，当然也可以重新定义<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3</span></span><br></pre></td></tr></table></figure>## #if<p></p><p>作用，实现条件编译 #if 可以配合defined #elif #else || &amp;&amp; ！等宏和运算符使用 例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_1<span class="comment">//定义USE_1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_1)</span></span><br><span class="line"><span class="comment">//定义了USE_1，编译这一段</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_2)</span></span><br><span class="line"><span class="comment">//定义了USE_2，编译这一段</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(PI) &amp;&amp; (PI==3)</span></span><br><span class="line"><span class="comment">//如果之前有#define PI 3则编译这一段</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//上面三个条件都不满足编译这一段</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>除#if外，还有#ifdef（如果定义了xx）#ifndef（如果没定义 xx） #if #ifndef #ifdef需要和#endif配合<br>条件编译最常见的作用，防止头文件重复包含<br>我们知道#include的作用是把include的文件内容拷贝到当前位置，如果多个头文件同时包含了一个头文件，那么这个头文件会重复展开到当前源文件中。或者如果a.h中#include "b.h"，b.h中有#include“a.h”，两个头文件相互展开，宏预处理的时候就会陷入死循环。为避免以上情况，一般采用条件编译作头文件保护。<br>如MSVC的&lt;stdio.h&gt;<p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _INC_STDIO </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INC_STDIO</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果同一个源文件第一次展开stdio.h，_INC_STDIO就会被定义，第二次展开时，由于_INC_STDIO已经被定义，就不会再把#ifndef _INC_STDIO后面的内容再次展开。</p><h1 id="c语言内存模型">C语言内存模型</h1><p>C语言数据的内存分为常量区，全局区（.bss和.data），堆区(heap)，栈区(stack)</p><ol type="1"><li>常量区<br>常量区用于储存代码和常量等，如一个局部变量int a = 0x12345678;这个0x12345678在a生成之前就存在常量区。 常量一般保存在ROM中。<br>注意a不是常量，a存放在栈中</li><li>全局区 在全局区的变量会在程序中一直占用内存。.bss段放程序中未初始化的或者初始化为0的变量；.data存放程序中已初始化的全局变量</li><li>堆区 在C语言中，用malloc分配的内存在堆上，堆区的内存可以用free在不需要的释放，不会一直占用内存。在单片机程序中，一般很少使用堆区。</li><li>栈区 栈是一个后进先出结构，在程序执行过程中是必须的。在函数调用过程中需要让栈增加，来保存函数的局部变量，形参。函数返回时栈减小，实现内存的回收。</li></ol><h1 id="变量生存期和作用域">变量生存期和作用域</h1><p>生存期是针对程序运行时，作用域是针对编译时</p><h2 id="作用域对单一文件">作用域（对单一文件）</h2><ol type="1"><li>在"{}"以内的变量（局部变量）只能被"{}"以内的语句调用到，不能被"{}"以外的语句调用到</li><li>在所有"{}"以外的变量（全局变量）可以被所有语句调用到</li><li>两个不同作用域的变量名相同且都可以用到时，使用作用范围小的变量。</li></ol><h2 id="全局变量声明与定义">全局变量声明与定义</h2><p>之前说过函数的声明，同样，全局变量的声明和定义与函数十分相似。在另一个文件中调用另一个文件的全局变量也需要声明，声明可以有多次，定义只能有一次。 声明比函数声明多extern关键字（函数声明默认有extern），而且只有全局变量才能被另一个文件调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****a.c******/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> var_b; <span class="comment">//声明外部变量var_b</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    var_b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****b.c******/</span></span><br><span class="line"><span class="keyword">int</span> var_b;<span class="comment">//定义全局变量var_b</span></span><br></pre></td></tr></table></figure>extern声明变量和同声明函数一样，只是告诉编译器这里有一个全局变量，但是在哪里定义的不知道，编译器只能告诉链接器这个文件需要一个这样的变量，这个变量由链接器去到其他文件找。<br>static修饰的全局变量只能在当前文件起作用，static修饰的函数只能在当前文件起作用，编译的时候编译器不会把它们暴露出来，链接器看不见。不用static修饰的全局变量和函数在编译时编译器告诉链接器这个文件有哪些变量和函数是可以被其他文件调用的，链接器就知道这些变量和函数可能被用到。 ## 变量的生存期 生存期是针对程序运行时。<br>全局变量，也就是在所有"{}"以外定义的变量（无论有没有static修饰），注意是定义，声明是给编译器看的，全局变量和函数，不管声明了多少次，最后运行的时候只有定义的那一个。上例中var_b就是全局变量，在a.c中用extern声明的var_b和b.c中的var_b在链接时合成一个。<br>全局变量是存储在内存的全局区，从程序开始执行到结束，这个变量的位置一直在，正常情况下不会被其他变量占据。生存期为整个程序。 局部静态变量，在"{}"以内定义，并用static修饰的变量。虽然作用域只有当前"{}"内，但也是分配在全局区，生存期为整个程序。该变量只初始化一次。<br>局部变量，在"{}"以内定义，不用static修饰的变量。分配在栈区，在调用该函数时，栈增加，为该函数的所有局部变量提供内存空间，函数调用结束时，栈空间回收，局部变量消失。 下面一个例子说明不同的变量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****b.c******/</span></span><br><span class="line"><span class="keyword">int</span> var_b;<span class="comment">//定义全局变量var_b</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var_b_temp = <span class="number">2</span>;<span class="comment">//局部变量，当调用函数fun_b时其出生，fun_b返回时其死亡</span></span><br><span class="line">    <span class="keyword">static</span> var_b_static = <span class="number">3</span>; </span><br><span class="line">    <span class="comment">//静态局部变量，</span></span><br><span class="line">    <span class="comment">//程序主函数开始前其被初始化为3，仅被初始化一次，</span></span><br><span class="line">    <span class="comment">//仅在当前函数内可见，生存期为整个程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="static与extern在c语言中的作用">static与extern在C语言中的作用</h2><p>下面总结一些static与extern在C语言的作用，也是对上面的一个梳理 ### 对于全局变量和函数 使用static修饰的全局变量和函数，只对整个源文件可见，其他源文件不可见。例如，可以在a.c和b.c中都定义static void fun_ab(){}和static void var_ab;两个文件中同名的函数或变量在内存中是两个不同的东西，链接的时候不会将它们合在一起。<br>不使用static修饰的全局变量和函数，编译器会将它们暴露出来。如果在a.c中调用b.c定义的函数和变量。需要在a.c中用extern声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> var_b;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>函数声明时extern可省略。不要在变量声明时初始化。 ### 对于局部变量 局部变量的作用域为当前"{}"内<br>不用static修饰的局部变量分配在栈区，函数调用时出生，函数返回时死亡。不要返回一个这种变量的地址！<br>用static修饰的局部变量分配在全局。生存期为整个程序运行时，可以返回这种变量的地址。<p></p><h1 id="c语言与c函数相互调用">C语言与C++函数相互调用</h1><p>C++函数支持重载，编译器为了让链接器知道链接哪个函数，在生成函数名时把函数参数加入到函数名中。如：c.cpp中定义以下两个函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_c</span><span class="params">(<span class="keyword">int</span> var)</span></span>&#123;&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_c</span><span class="params">(<span class="keyword">float</span> var)</span></span>&#123;&#125;。</span><br></pre></td></tr></table></figure>编译生成函数名时会生成类似 _fun_c_int,_fun_c_float这样的函数名。而C语言生成函数名时不包含参数信息。链接器在链接时不知道哪个.o是C语言源文件生成的，哪个是cpp生成的，互相调用时就出现调用的函数名和定义的函数名不一样的情况。<br>我们可以让编译器在cpp文件定义和调用函数时采用C语言的函数生成规则。方法是在定义或声明cpp函数前加 extern "C"，例，在c.cpp中<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">fun_c1</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>或者<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">fun_c1</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>表示这个函数名的生成方式按照C语言的生成方式。如果向对一个文件中所有的函数用C语言的命名方式，可以<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line">    <span class="comment">//“&#123;&#125;”内放函数的声明或定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>大括号内的所有被声明和定义的函数都用C语言方式生成。 在C++代码中调用C语言程序也是用以上两种方法在调用之前的声明中加extern "C"<br>注： 1. extern "C"只改变函数名的生成方式，在extern "C"或extern "C"{}修饰的语句依然可以用C++的全部特性，除了函数重载。 2. extern "C"是C++特有的语句，在C语言源文件中无法通过编译。当一个头文件被C源程序和C++程序共同#include时，采用以下方法：<p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********c.h**********/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> C_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C_H<span class="comment">//头文件保护</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//#ifdef __cplusplus</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_c1</span><span class="params">()</span></span>;<span class="comment">//不能重载</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;<span class="comment">//和extern "C"后面的"&#123;"配对</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//#ifdef __cplusplus</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//#ifndef C_H</span></span></span><br></pre></td></tr></table></figure><p>其中__cplusplus是一个宏，当源文件为C++时其被定义。当源文件是C++时，宏处理后保留extern "C"，函数的命名按照C语言生成。源文件是C语言时，没有定义__cplusplus，宏处理后去掉extern "C"，保证C语言正常编译。 # const 和 volatile const 在C语言中表示一个变量是只读的。可以提高代码的可读性。编译器有可能将const变量优化成常量。 volatile表示一个变量是易变的，被volatile修饰的关键字有可能被外部改变（如：IO口，DMA，其他线程），要求cpu每次使用该变量都要从内存中读取。<br>在cpu中，对于频繁使用的变量，编译器可能把它优化成寄存器变量。因为cpu都是用寄存器中的变量进行运算，如果需要运算内存的变量，需要读到寄存器中。C语言不能直接操作寄存器。<br>把变量放到寄存器中可以加快运行速度。但是如果这个变量的内存被外部改了，包括IO口的变化，串口寄存器接收到一个数据，全局变量被中断函数修改。cpu无法知道这个变量的内存已经被修改，还在使用存在寄存器的值。就会造成运行过程的错误。例如<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(flag)&#123;&#125;</span><br><span class="line"><span class="comment">//do somthing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可能你的本意是flag在某个中断函数中变为false，这里等待flag为false。但是单独看这一个文件（别忘了编译是按文件进行的，编译器不知道其他文件有什么），flag一直是true编译器有可能把flag优化成一个寄存器变量或者常量。之后一直while(true){}，//do something的部分永远不会执行到。解决的办法是定义flag的时候加上volatile。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure>编译器读取flag的时候永远会在内存中取。<br>volatile适用于中断和主函数直间需要传值的全局变量。但是不可过度使用volatile，会阻止编译器优化，影响运行速度。<p></p></iostream><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Sep 14 2020 22:50:17 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;编译期和运行期未定义行为&quot;&gt;编译期和运行期，未定义行为&lt;/h1&gt;&lt;p&gt;C语言和C++中一些规范是针对编译期的，一些是针对运行期的。在学习的时候要关注哪些是编译期的规定，哪些是运行期的规定。&lt;br&gt;C语言和C++有大量的未定义行为，具体实现取决于编译器的设计。比如i=1;(++i)+(i++)的值就是未定义的。不同编译器结果不同。在一条语句中，对一个变量改变两次及以上的结果是未定义的。还有一个，int占多少字节也是标准中没有规定的，标准中只规定int至少是16位，int长度不能小于short。int的长度是编译器决定的。在32位、64位CPU中，编译器的int长度一般是32位。&lt;br&gt;不要把某一种编译器测试的结果就当成C和C++的标准。编译器是根据标准实现的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="单片机" scheme="https://IronSublimate.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>重定向printf</title>
    <link href="https://ironsublimate.github.io/2020/06/29/24907/"/>
    <id>https://ironsublimate.github.io/2020/06/29/24907/</id>
    <published>2020-06-29T08:21:21.790Z</published>
    <updated>2020-09-14T03:54:48.152Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 14 2020 22:50:18 GMT+0800 (中国标准时间) --><h1 id="重定向printf">重定向printf</h1><p>可以用于iar,keil等编译器</p><ol type="1"><li>在工程中任意源文件中定义fputc<a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//这里改成向串口输出的函数</span></span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>之后可以用printf fprintf putchar等所有stdio的输出函数</p><h3 id="原理">原理</h3><p>iar keil等编译器自己实现了printf等函数，最后都是调用fputc输出<br>fputc也可以根据穿进来的FILE* 参数自己定义向哪里输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> FILE screen;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f==<span class="built_in">stdout</span>)&#123;</span><br><span class="line"><span class="comment">//这里改成向串口输出的函数</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f==&amp;screen)&#123;</span><br><span class="line"><span class="comment">//这里改成向显示屏输出的函数</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>printf会向stdout输出，向其他地方输出用fprintf第一个参数指定向哪个设备输出<p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Sep 14 2020 22:50:18 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;重定向printf&quot;&gt;重定向printf&lt;/h1&gt;&lt;p&gt;可以用于iar,keil等编译器&lt;/p&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;在工程中任意源文件中定义fputc&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="单片机" scheme="https://IronSublimate.github.io/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
      <category term="单片机" scheme="https://IronSublimate.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ironsublimate.github.io/2020/06/29/16107/"/>
    <id>https://ironsublimate.github.io/2020/06/29/16107/</id>
    <published>2020-06-29T07:40:37.720Z</published>
    <updated>2020-09-14T02:30:28.737Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 14 2020 22:50:17 GMT+0800 (中国标准时间) --><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<a id="more"></a> ## Quick Start</p><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Sep 14 2020 22:50:17 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Helloworld" scheme="https://IronSublimate.github.io/categories/Helloworld/"/>
    
    
  </entry>
  
</feed>
